#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define DIRSTR "hpctoolkit-syswide-measurements"

FILE* filefds[1024]; //max 1024 CPU on a node

int main(int argc, char **argv)
{
  int callstack_flag = 0;
  char exename[1024]; //exename
  char symname[1024]; //symbol name
  uint64_t time, ip, cpu, pid, len;
  char *end;

  if (argc < 2) {
    printf("please specify the file generated by perf script\n");
    exit(0);
  }
  mkdir(DIRSTR, 0755);

  FILE *fd = fopen(argv[1], "r");
  if (!fd) {
    printf("file open fails\n");
    exit(0);
  }
  char buffer[1024];
  char *cptr = NULL; //current pointer
  char *ptr = NULL;
  while(fgets(buffer, sizeof(buffer), fd) != NULL) {
    time = ip = cpu = pid = 0;
    if (buffer[0] == '#') {
      if ((ptr = strstr(buffer, "cmdline"))) {
        if (strstr(ptr, "-g")) callstack_flag = 1;
      }
      continue;
    }
    
    cptr = buffer;
    while (*cptr == ' ' || *cptr == '\t') cptr++;
    if((ptr = strstr(cptr, " "))) {
      strncpy(exename, cptr, ptr-cptr);
      exename[ptr-cptr] = '\0';
//      printf("exename is %s\n", exename);
    }
    cptr = ptr + 1;
    while (*cptr == ' ' || *cptr == '\t') cptr++;
    pid = strtoll(cptr, NULL, 10);
//    printf("pid is %llu\n", pid);
    
    // sometimes, no [cpu] shows in the perf data
    if ((ptr = strstr(cptr, " "))) {
      while (*cptr == ' ' || *cptr == '\t') cptr++;
      cptr = ptr+1;
      if(*cptr == '[') {
        cpu = strtoll(cptr+1, NULL, 10);
//        printf("cpu is %llu\n", cpu);
      }
      else cptr--; //backoff 1 for searching the next entry
    }
    if ((ptr = strstr(cptr, " "))) {
      cptr = ptr + 1;
      while (*cptr == ' ' || *cptr == '\t') cptr++;
      uint64_t tmp1, tmp2;
      tmp1 = strtoll(cptr, NULL, 10);
      ptr = strstr(cptr, ".");
      cptr = ptr + 1;
      tmp2 = strtoll(cptr, NULL, 10);
      time = tmp1*1000000 + tmp2;
//      printf("time is %llu\n", time);
    }
    if(!filefds[cpu]) {
      char name[1024];
      sprintf(name, "%s/syswide-%03d-000-%d-%d-0", DIRSTR, (int)cpu, gethostid(), getpid());
      filefds[cpu] = fopen(name, "wb");
      if (!filefds[cpu]) {
        fprintf(stderr, "cannot open file\n");
        exit(0);
      }
    }
    len = strlen(exename);
    fwrite(&len, sizeof(len), 1, filefds[cpu]);
    fwrite(exename, len, 1, filefds[cpu]);
    fwrite(&pid, sizeof(pid), 1, filefds[cpu]);
    fwrite(&cpu, sizeof(cpu), 1, filefds[cpu]);
    fwrite(&time, sizeof(time), 1, filefds[cpu]);

    if (callstack_flag) {
      while(fgets(buffer, sizeof(buffer), fd) != NULL) {
        if (buffer[0] == '\n'){ // finish the call stack
	  ip = 0x1111111;
	  fwrite(&ip, sizeof(ip), 1, filefds[cpu]);
	  break;
	}
	cptr = buffer;
        while(*cptr == '\t' || *cptr == ' ') cptr++;
  	// this is needed, seems the callstack may overflow the 64 bit (ip is not quite useful in our program)
        if (*cptr == 'f')
   	  cptr++;
	ip = strtoll(cptr, &end, 16);
//        printf("ip is %llx\n", ip);
	cptr = end;

  	if ((ptr = strstr(cptr, " "))) {
	  cptr = ptr + 1;
	  ptr = strstr(cptr, " ");
    	  strncpy(symname, cptr, (ptr-cptr));
	  symname[ptr-cptr] = '\0';
//	  printf("symname is %s\n", symname);
    	}
        if (symname[0] == '\0') { // no name
	  strcpy(symname, "unknown");
        }
	fwrite(&ip, sizeof(ip), 1, filefds[cpu]);
 	len = strlen(symname);
	fwrite(&len, sizeof(len), 1, filefds[cpu]);
	fwrite(symname, len, 1, filefds[cpu]);
      }
    }
    // no call stack info
    else {
      ptr = strstr(cptr, ":");
      cptr = ptr+1;
      ptr = strstr(cptr, ":");
      cptr = ptr+1;
      while(*cptr == ' ' || *cptr == '\t') cptr++;
      if (*cptr == 'f')
        cptr++;
      ip = strtoll(cptr, &end, 16);
//      printf("ip is %llx\n", ip);
      cptr = end;
    
      if ((ptr = strstr(cptr, " "))) {
	cptr = ptr + 1;
	ptr = strstr(cptr, " ");
  	strncpy(symname, cptr, (ptr-cptr));
  	symname[ptr-cptr] = '\0';
//	printf("symname is %s\n", symname);
      }
      if (symname[0] == '\0') { // no name
        strcpy(symname, "unknown");
      }
      fwrite(&ip, sizeof(ip), 1, filefds[cpu]);
      len = strlen(symname);
      fwrite(&len, sizeof(len), 1, filefds[cpu]);
      fwrite(symname, len, 1, filefds[cpu]);
      // end mark
      ip = 0x1111111;
      fwrite(&ip, sizeof(ip), 1, filefds[cpu]);
    }
  }

  int i;
  for(i = 0; i < 1024; i++) {
    if (filefds[i]) fclose(filefds[i]);
  }

  return 0;
}
